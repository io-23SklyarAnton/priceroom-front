4c82ddcbe6a56b05b759ae9144e9cd03
'use strict';

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
var picocolors = require('picocolors');
var jsTokens = require('js-tokens');
var helperValidatorIdentifier = require('@babel/helper-validator-identifier');
function isColorSupported() {
  return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
}
var compose = function compose(f, g) {
  return function (v) {
    return f(g(v));
  };
};
function buildDefs(colors) {
  return {
    keyword: colors.cyan,
    capitalized: colors.yellow,
    jsxIdentifier: colors.yellow,
    punctuator: colors.yellow,
    number: colors.magenta,
    string: colors.green,
    regex: colors.magenta,
    comment: colors.gray,
    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
    gutter: colors.gray,
    marker: compose(colors.red, colors.bold),
    message: compose(colors.red, colors.bold),
    reset: colors.reset
  };
}
var defsOn = buildDefs(picocolors.createColors(true));
var defsOff = buildDefs(picocolors.createColors(false));
function getDefs(enabled) {
  return enabled ? defsOn : defsOff;
}
var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
var BRACKET = /^[()[\]{}]$/;
var tokenize;
{
  var JSX_TAG = /^[a-z][\w-]*$/i;
  var getTokenType = function getTokenType(token, offset, text) {
    if (token.type === "name") {
      if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
        return "keyword";
      }
      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
        return "jsxIdentifier";
      }
      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }
    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }
    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }
    return token.type;
  };
  tokenize = /*#__PURE__*/_regeneratorRuntime().mark(function tokenize(text) {
    var match, token;
    return _regeneratorRuntime().wrap(function tokenize$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(match = jsTokens["default"].exec(text))) {
            _context.next = 6;
            break;
          }
          token = jsTokens.matchToToken(match);
          _context.next = 4;
          return {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        case 4:
          _context.next = 0;
          break;
        case 6:
        case "end":
          return _context.stop();
      }
    }, tokenize);
  });
}
function highlight(text) {
  if (text === "") return "";
  var defs = getDefs(true);
  var highlighted = "";
  var _iterator = _createForOfIteratorHelper(tokenize(text)),
    _step;
  try {
    var _loop = function _loop() {
      var _step$value = _step.value,
        type = _step$value.type,
        value = _step$value.value;
      if (type in defs) {
        highlighted += value.split(NEWLINE$1).map(function (str) {
          return defs[type](str);
        }).join("\n");
      } else {
        highlighted += value;
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return highlighted;
}
var deprecationWarningShown = false;
var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(loc, source, opts) {
  var startLoc = Object.assign({
    column: 0,
    line: -1
  }, loc.start);
  var endLoc = Object.assign({}, startLoc, loc.end);
  var _ref = opts || {},
    _ref$linesAbove = _ref.linesAbove,
    linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
    _ref$linesBelow = _ref.linesBelow,
    linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;
  var startLine = startLoc.line;
  var startColumn = startLoc.column;
  var endLine = endLoc.line;
  var endColumn = endLoc.column;
  var start = Math.max(startLine - (linesAbove + 1), 0);
  var end = Math.min(source.length, endLine + linesBelow);
  if (startLine === -1) {
    start = 0;
  }
  if (endLine === -1) {
    end = source.length;
  }
  var lineDiff = endLine - startLine;
  var markerLines = {};
  if (lineDiff) {
    for (var i = 0; i <= lineDiff; i++) {
      var lineNumber = i + startLine;
      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        var sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        var _sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, _sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }
  return {
    start: start,
    end: end,
    markerLines: markerLines
  };
}
function codeFrameColumns(rawLines, loc) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
  var defs = getDefs(shouldHighlight);
  var lines = rawLines.split(NEWLINE);
  var _getMarkerLines = getMarkerLines(loc, lines, opts),
    start = _getMarkerLines.start,
    end = _getMarkerLines.end,
    markerLines = _getMarkerLines.markerLines;
  var hasColumns = loc.start && typeof loc.start.column === "number";
  var numberMaxWidth = String(end).length;
  var highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
  var frame = highlightedLines.split(NEWLINE, end).slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
    var gutter = " ".concat(paddedNumber, " |");
    var hasMarker = markerLines[number];
    var lastMarkerLine = !markerLines[number + 1];
    if (hasMarker) {
      var markerLine = "";
      if (Array.isArray(hasMarker)) {
        var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        var numberOfMarkers = hasMarker[1] || 1;
        markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
        if (lastMarkerLine && opts.message) {
          markerLine += " " + defs.message(opts.message);
        }
      }
      return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? " ".concat(line) : "", markerLine].join("");
    } else {
      return " ".concat(defs.gutter(gutter)).concat(line.length > 0 ? " ".concat(line) : "");
    }
  }).join("\n");
  if (opts.message && !hasColumns) {
    frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
  }
  if (shouldHighlight) {
    return defs.reset(frame);
  } else {
    return frame;
  }
}
function index(rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (!deprecationWarningShown) {
    deprecationWarningShown = true;
    var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning) {
      process.emitWarning(message, "DeprecationWarning");
    } else {
      var deprecationError = new Error(message);
      deprecationError.name = "DeprecationWarning";
      console.warn(new Error(message));
    }
  }
  colNumber = Math.max(colNumber, 0);
  var location = {
    start: {
      column: colNumber,
      line: lineNumber
    }
  };
  return codeFrameColumns(rawLines, location, opts);
}
exports.codeFrameColumns = codeFrameColumns;
exports["default"] = index;
exports.highlight = highlight;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc0NvbG9yU3VwcG9ydGVkIiwicHJvY2VzcyIsIl90eXBlb2YiLCJlbnYiLCJGT1JDRV9DT0xPUiIsInBpY29jb2xvcnMiLCJjb21wb3NlIiwiZiIsImciLCJ2IiwiYnVpbGREZWZzIiwiY29sb3JzIiwia2V5d29yZCIsImN5YW4iLCJjYXBpdGFsaXplZCIsInllbGxvdyIsImpzeElkZW50aWZpZXIiLCJwdW5jdHVhdG9yIiwibnVtYmVyIiwibWFnZW50YSIsInN0cmluZyIsImdyZWVuIiwicmVnZXgiLCJjb21tZW50IiwiZ3JheSIsImludmFsaWQiLCJ3aGl0ZSIsImJnUmVkIiwiYm9sZCIsImd1dHRlciIsIm1hcmtlciIsInJlZCIsIm1lc3NhZ2UiLCJyZXNldCIsImRlZnNPbiIsImNyZWF0ZUNvbG9ycyIsImRlZnNPZmYiLCJnZXREZWZzIiwiZW5hYmxlZCIsInNvbWV0aW1lc0tleXdvcmRzIiwiU2V0IiwiTkVXTElORSQxIiwiQlJBQ0tFVCIsInRva2VuaXplIiwiSlNYX1RBRyIsImdldFRva2VuVHlwZSIsInRva2VuIiwib2Zmc2V0IiwidGV4dCIsInR5cGUiLCJoZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyIiwiaXNLZXl3b3JkIiwidmFsdWUiLCJpc1N0cmljdFJlc2VydmVkV29yZCIsImhhcyIsInRlc3QiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJtYXRjaCIsIndyYXAiLCJ0b2tlbml6ZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwianNUb2tlbnMiLCJleGVjIiwibWF0Y2hUb1Rva2VuIiwiaW5kZXgiLCJzdG9wIiwiaGlnaGxpZ2h0IiwiZGVmcyIsImhpZ2hsaWdodGVkIiwiX2l0ZXJhdG9yIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJfc3RlcCIsIl9sb29wIiwiX3N0ZXAkdmFsdWUiLCJzcGxpdCIsIm1hcCIsInN0ciIsImpvaW4iLCJzIiwibiIsImRvbmUiLCJlcnIiLCJlIiwiZGVwcmVjYXRpb25XYXJuaW5nU2hvd24iLCJORVdMSU5FIiwiZ2V0TWFya2VyTGluZXMiLCJsb2MiLCJzb3VyY2UiLCJvcHRzIiwic3RhcnRMb2MiLCJPYmplY3QiLCJhc3NpZ24iLCJjb2x1bW4iLCJsaW5lIiwic3RhcnQiLCJlbmRMb2MiLCJlbmQiLCJfcmVmIiwiX3JlZiRsaW5lc0Fib3ZlIiwibGluZXNBYm92ZSIsIl9yZWYkbGluZXNCZWxvdyIsImxpbmVzQmVsb3ciLCJzdGFydExpbmUiLCJzdGFydENvbHVtbiIsImVuZExpbmUiLCJlbmRDb2x1bW4iLCJNYXRoIiwibWF4IiwibWluIiwibGVuZ3RoIiwibGluZURpZmYiLCJtYXJrZXJMaW5lcyIsImkiLCJsaW5lTnVtYmVyIiwic291cmNlTGVuZ3RoIiwiY29kZUZyYW1lQ29sdW1ucyIsInJhd0xpbmVzIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwic2hvdWxkSGlnaGxpZ2h0IiwiZm9yY2VDb2xvciIsImhpZ2hsaWdodENvZGUiLCJsaW5lcyIsIl9nZXRNYXJrZXJMaW5lcyIsImhhc0NvbHVtbnMiLCJudW1iZXJNYXhXaWR0aCIsIlN0cmluZyIsImhpZ2hsaWdodGVkTGluZXMiLCJmcmFtZSIsInBhZGRlZE51bWJlciIsImNvbmNhdCIsImhhc01hcmtlciIsImxhc3RNYXJrZXJMaW5lIiwibWFya2VyTGluZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcmtlclNwYWNpbmciLCJyZXBsYWNlIiwibnVtYmVyT2ZNYXJrZXJzIiwicmVwZWF0IiwiY29sTnVtYmVyIiwiZW1pdFdhcm5pbmciLCJkZXByZWNhdGlvbkVycm9yIiwiRXJyb3IiLCJuYW1lIiwiY29uc29sZSIsIndhcm4iLCJsb2NhdGlvbiJdLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWZzLnRzIiwiLi4vc3JjL2hpZ2hsaWdodC50cyIsIi4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGljb2NvbG9ycywgeyBjcmVhdGVDb2xvcnMgfSBmcm9tIFwicGljb2NvbG9yc1wiO1xuaW1wb3J0IHR5cGUgeyBDb2xvcnMsIEZvcm1hdHRlciB9IGZyb20gXCJwaWNvY29sb3JzL3R5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbG9yU3VwcG9ydGVkKCkge1xuICByZXR1cm4gKFxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxleGV5cmFzcG9wb3YvcGljb2NvbG9ycy9pc3N1ZXMvNjJcbiAgICB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgKHByb2Nlc3MuZW52LkZPUkNFX0NPTE9SID09PSBcIjBcIiB8fCBwcm9jZXNzLmVudi5GT1JDRV9DT0xPUiA9PT0gXCJmYWxzZVwiKVxuICAgICAgPyBmYWxzZVxuICAgICAgOiBwaWNvY29sb3JzLmlzQ29sb3JTdXBwb3J0ZWRcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgSW50ZXJuYWxUb2tlblR5cGUgPVxuICB8IFwia2V5d29yZFwiXG4gIHwgXCJjYXBpdGFsaXplZFwiXG4gIHwgXCJqc3hJZGVudGlmaWVyXCJcbiAgfCBcInB1bmN0dWF0b3JcIlxuICB8IFwibnVtYmVyXCJcbiAgfCBcInN0cmluZ1wiXG4gIHwgXCJyZWdleFwiXG4gIHwgXCJjb21tZW50XCJcbiAgfCBcImludmFsaWRcIjtcblxudHlwZSBVSVRva2VucyA9IFwiZ3V0dGVyXCIgfCBcIm1hcmtlclwiIHwgXCJtZXNzYWdlXCI7XG5cbmV4cG9ydCB0eXBlIERlZnMgPSB7XG4gIFtfIGluIEludGVybmFsVG9rZW5UeXBlIHwgVUlUb2tlbnMgfCBcInJlc2V0XCJdOiBGb3JtYXR0ZXI7XG59O1xuXG5jb25zdCBjb21wb3NlOiA8VCwgVSwgVj4oZjogKGd2OiBVKSA9PiBWLCBnOiAodjogVCkgPT4gVSkgPT4gKHY6IFQpID0+IFYgPVxuICAoZiwgZykgPT4gdiA9PlxuICAgIGYoZyh2KSk7XG5cbi8qKlxuICogU3R5bGVzIGZvciB0b2tlbiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gYnVpbGREZWZzKGNvbG9yczogQ29sb3JzKTogRGVmcyB7XG4gIHJldHVybiB7XG4gICAga2V5d29yZDogY29sb3JzLmN5YW4sXG4gICAgY2FwaXRhbGl6ZWQ6IGNvbG9ycy55ZWxsb3csXG4gICAganN4SWRlbnRpZmllcjogY29sb3JzLnllbGxvdyxcbiAgICBwdW5jdHVhdG9yOiBjb2xvcnMueWVsbG93LFxuICAgIG51bWJlcjogY29sb3JzLm1hZ2VudGEsXG4gICAgc3RyaW5nOiBjb2xvcnMuZ3JlZW4sXG4gICAgcmVnZXg6IGNvbG9ycy5tYWdlbnRhLFxuICAgIGNvbW1lbnQ6IGNvbG9ycy5ncmF5LFxuICAgIGludmFsaWQ6IGNvbXBvc2UoY29tcG9zZShjb2xvcnMud2hpdGUsIGNvbG9ycy5iZ1JlZCksIGNvbG9ycy5ib2xkKSxcblxuICAgIGd1dHRlcjogY29sb3JzLmdyYXksXG4gICAgbWFya2VyOiBjb21wb3NlKGNvbG9ycy5yZWQsIGNvbG9ycy5ib2xkKSxcbiAgICBtZXNzYWdlOiBjb21wb3NlKGNvbG9ycy5yZWQsIGNvbG9ycy5ib2xkKSxcblxuICAgIHJlc2V0OiBjb2xvcnMucmVzZXQsXG4gIH07XG59XG5cbmNvbnN0IGRlZnNPbiA9IGJ1aWxkRGVmcyhjcmVhdGVDb2xvcnModHJ1ZSkpO1xuY29uc3QgZGVmc09mZiA9IGJ1aWxkRGVmcyhjcmVhdGVDb2xvcnMoZmFsc2UpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZnMoZW5hYmxlZDogYm9vbGVhbik6IERlZnMge1xuICByZXR1cm4gZW5hYmxlZCA/IGRlZnNPbiA6IGRlZnNPZmY7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFRva2VuIGFzIEpTVG9rZW4sIEpTWFRva2VuIH0gZnJvbSBcImpzLXRva2Vuc1wiO1xuaW1wb3J0IGpzVG9rZW5zIGZyb20gXCJqcy10b2tlbnNcIjtcblxuaW1wb3J0IHtcbiAgaXNTdHJpY3RSZXNlcnZlZFdvcmQsXG4gIGlzS2V5d29yZCxcbn0gZnJvbSBcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIjtcblxuaW1wb3J0IHsgZ2V0RGVmcywgdHlwZSBJbnRlcm5hbFRva2VuVHlwZSB9IGZyb20gXCIuL2RlZnMudHNcIjtcblxuLyoqXG4gKiBOYW1lcyB0aGF0IGFyZSBhbHdheXMgYWxsb3dlZCBhcyBpZGVudGlmaWVycywgYnV0IGFsc28gYXBwZWFyIGFzIGtleXdvcmRzXG4gKiB3aXRoaW4gY2VydGFpbiBzeW50YWN0aWMgcHJvZHVjdGlvbnMuXG4gKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1rZXl3b3Jkcy1hbmQtcmVzZXJ2ZWQtd29yZHNcbiAqXG4gKiBgdGFyZ2V0YCBoYXMgYmVlbiBvbWl0dGVkIHNpbmNlIGl0IGlzIHZlcnkgbGlrZWx5IGdvaW5nIHRvIGJlIGEgZmFsc2VcbiAqIHBvc2l0aXZlLlxuICovXG5jb25zdCBzb21ldGltZXNLZXl3b3JkcyA9IG5ldyBTZXQoW1wiYXNcIiwgXCJhc3luY1wiLCBcImZyb21cIiwgXCJnZXRcIiwgXCJvZlwiLCBcInNldFwiXSk7XG5cbnR5cGUgVG9rZW4gPSB7XG4gIHR5cGU6IEludGVybmFsVG9rZW5UeXBlIHwgXCJ1bmNvbG9yZWRcIjtcbiAgdmFsdWU6IHN0cmluZztcbn07XG5cbi8qKlxuICogUmVnRXhwIHRvIHRlc3QgZm9yIG5ld2xpbmVzIGluIHRlcm1pbmFsLlxuICovXG5jb25zdCBORVdMSU5FID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuLyoqXG4gKiBSZWdFeHAgdG8gdGVzdCBmb3IgdGhlIHRocmVlIHR5cGVzIG9mIGJyYWNrZXRzLlxuICovXG5jb25zdCBCUkFDS0VUID0gL15bKClbXFxde31dJC87XG5cbmxldCB0b2tlbml6ZTogKFxuICB0ZXh0OiBzdHJpbmcsXG4pID0+IEdlbmVyYXRvcjx7IHR5cGU6IEludGVybmFsVG9rZW5UeXBlIHwgXCJ1bmNvbG9yZWRcIjsgdmFsdWU6IHN0cmluZyB9PjtcblxuaWYgKHByb2Nlc3MuZW52LkJBQkVMXzhfQlJFQUtJTkcpIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0b2tlbiwgc3BlY2lmeWluZyBwdW5jdHVhdG9yIHR5cGUuXG4gICAqL1xuICBjb25zdCBnZXRUb2tlblR5cGUgPSBmdW5jdGlvbiAoXG4gICAgdG9rZW46IEpTVG9rZW4gfCBKU1hUb2tlbixcbiAgKTogSW50ZXJuYWxUb2tlblR5cGUgfCBcInVuY29sb3JlZFwiIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJJZGVudGlmaWVyTmFtZVwiKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGlzS2V5d29yZCh0b2tlbi52YWx1ZSkgfHxcbiAgICAgICAgaXNTdHJpY3RSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUsIHRydWUpIHx8XG4gICAgICAgIHNvbWV0aW1lc0tleXdvcmRzLmhhcyh0b2tlbi52YWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi52YWx1ZVswXSAhPT0gdG9rZW4udmFsdWVbMF0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gXCJjYXBpdGFsaXplZFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSBcIlB1bmN0dWF0b3JcIiAmJiBCUkFDS0VULnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJ1bmNvbG9yZWRcIjtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJJbnZhbGlkXCIgJiYgdG9rZW4udmFsdWUgPT09IFwiQFwiKSB7XG4gICAgICByZXR1cm4gXCJwdW5jdHVhdG9yXCI7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICBjYXNlIFwiSlNYU3RyaW5nXCI6XG4gICAgICBjYXNlIFwiTm9TdWJzdGl0dXRpb25UZW1wbGF0ZVwiOlxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAgICAgY2FzZSBcIlJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gXCJyZWdleFwiO1xuXG4gICAgICBjYXNlIFwiUHVuY3R1YXRvclwiOlxuICAgICAgY2FzZSBcIkpTWFB1bmN0dWF0b3JcIjpcbiAgICAgICAgcmV0dXJuIFwicHVuY3R1YXRvclwiO1xuXG4gICAgICBjYXNlIFwiTXVsdGlMaW5lQ29tbWVudFwiOlxuICAgICAgY2FzZSBcIlNpbmdsZUxpbmVDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcblxuICAgICAgY2FzZSBcIkludmFsaWRcIjpcbiAgICAgIGNhc2UgXCJKU1hJbnZhbGlkXCI6XG4gICAgICAgIHJldHVybiBcImludmFsaWRcIjtcblxuICAgICAgY2FzZSBcIkpTWElkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIFwianN4SWRlbnRpZmllclwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJ1bmNvbG9yZWRcIjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gYSBzdHJpbmcgb2YgSlMgaW50byBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgKi9cbiAgdG9rZW5pemUgPSBmdW5jdGlvbiogKHRleHQ6IHN0cmluZyk6IEdlbmVyYXRvcjxUb2tlbj4ge1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YganNUb2tlbnModGV4dCwgeyBqc3g6IHRydWUgfSkpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlIFwiVGVtcGxhdGVIZWFkXCI6XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogdG9rZW4udmFsdWUuc2xpY2UoMCwgLTIpIH07XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInB1bmN0dWF0b3JcIiwgdmFsdWU6IFwiJHtcIiB9O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJUZW1wbGF0ZU1pZGRsZVwiOlxuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJwdW5jdHVhdG9yXCIsIHZhbHVlOiBcIn1cIiB9O1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IHRva2VuLnZhbHVlLnNsaWNlKDEsIC0yKSB9O1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJwdW5jdHVhdG9yXCIsIHZhbHVlOiBcIiR7XCIgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiVGVtcGxhdGVUYWlsXCI6XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInB1bmN0dWF0b3JcIiwgdmFsdWU6IFwifVwiIH07XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogdG9rZW4udmFsdWUuc2xpY2UoMSkgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6IGdldFRva2VuVHlwZSh0b2tlbiksXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvKipcbiAgICogUmVnRXhwIHRvIHRlc3QgZm9yIHdoYXQgc2VlbXMgdG8gYmUgYSBKU1ggdGFnIG5hbWUuXG4gICAqL1xuICBjb25zdCBKU1hfVEFHID0gL15bYS16XVtcXHctXSokL2k7XG5cbiAgLy8gVGhlIHRva2VuIGhlcmUgaXMgZGVmaW5lZCBpbiBqcy10b2tlbnNANC4gSG93ZXZlciB3ZSBkb24ndCBib3RoZXJcbiAgLy8gdHlwaW5nIGl0IHNpbmNlIHRoZSB3aG9sZSBibG9jayB3aWxsIGJlIHJlbW92ZWQgaW4gQmFiZWwgOFxuICBjb25zdCBnZXRUb2tlblR5cGUgPSBmdW5jdGlvbiAodG9rZW46IGFueSwgb2Zmc2V0OiBudW1iZXIsIHRleHQ6IHN0cmluZykge1xuICAgIGlmICh0b2tlbi50eXBlID09PSBcIm5hbWVcIikge1xuICAgICAgaWYgKFxuICAgICAgICBpc0tleXdvcmQodG9rZW4udmFsdWUpIHx8XG4gICAgICAgIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlLCB0cnVlKSB8fFxuICAgICAgICBzb21ldGltZXNLZXl3b3Jkcy5oYXModG9rZW4udmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIEpTWF9UQUcudGVzdCh0b2tlbi52YWx1ZSkgJiZcbiAgICAgICAgKHRleHRbb2Zmc2V0IC0gMV0gPT09IFwiPFwiIHx8IHRleHQuc2xpY2Uob2Zmc2V0IC0gMiwgb2Zmc2V0KSA9PT0gXCI8L1wiKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBcImpzeElkZW50aWZpZXJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnZhbHVlWzBdICE9PSB0b2tlbi52YWx1ZVswXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBcImNhcGl0YWxpemVkXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwicHVuY3R1YXRvclwiICYmIEJSQUNLRVQudGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0b2tlbi50eXBlID09PSBcImludmFsaWRcIiAmJlxuICAgICAgKHRva2VuLnZhbHVlID09PSBcIkBcIiB8fCB0b2tlbi52YWx1ZSA9PT0gXCIjXCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gXCJwdW5jdHVhdG9yXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuLnR5cGU7XG4gIH07XG5cbiAgdG9rZW5pemUgPSBmdW5jdGlvbiogKHRleHQ6IHN0cmluZykge1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gKGpzVG9rZW5zIGFzIGFueSkuZGVmYXVsdC5leGVjKHRleHQpKSkge1xuICAgICAgY29uc3QgdG9rZW4gPSAoanNUb2tlbnMgYXMgYW55KS5tYXRjaFRvVG9rZW4obWF0Y2gpO1xuXG4gICAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IGdldFRva2VuVHlwZSh0b2tlbiwgbWF0Y2guaW5kZXgsIHRleHQpLFxuICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodCh0ZXh0OiBzdHJpbmcpIHtcbiAgaWYgKHRleHQgPT09IFwiXCIpIHJldHVybiBcIlwiO1xuXG4gIGNvbnN0IGRlZnMgPSBnZXREZWZzKHRydWUpO1xuXG4gIGxldCBoaWdobGlnaHRlZCA9IFwiXCI7XG5cbiAgZm9yIChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgdG9rZW5pemUodGV4dCkpIHtcbiAgICBpZiAodHlwZSBpbiBkZWZzKSB7XG4gICAgICBoaWdobGlnaHRlZCArPSB2YWx1ZVxuICAgICAgICAuc3BsaXQoTkVXTElORSlcbiAgICAgICAgLm1hcChzdHIgPT4gZGVmc1t0eXBlIGFzIEludGVybmFsVG9rZW5UeXBlXShzdHIpKVxuICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0ZWQgKz0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpZ2hsaWdodGVkO1xufVxuIiwiaW1wb3J0IHsgZ2V0RGVmcywgaXNDb2xvclN1cHBvcnRlZCB9IGZyb20gXCIuL2RlZnMudHNcIjtcbmltcG9ydCB7IGhpZ2hsaWdodCB9IGZyb20gXCIuL2hpZ2hsaWdodC50c1wiO1xuXG5leHBvcnQgeyBoaWdobGlnaHQgfTtcblxubGV0IGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbnR5cGUgTG9jYXRpb24gPSB7XG4gIGNvbHVtbjogbnVtYmVyO1xuICBsaW5lOiBudW1iZXI7XG59O1xuXG50eXBlIE5vZGVMb2NhdGlvbiA9IHtcbiAgZW5kPzogTG9jYXRpb247XG4gIHN0YXJ0OiBMb2NhdGlvbjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8qKiBTeW50YXggaGlnaGxpZ2h0IHRoZSBjb2RlIGFzIEphdmFTY3JpcHQgZm9yIHRlcm1pbmFscy4gZGVmYXVsdDogZmFsc2UgKi9cbiAgaGlnaGxpZ2h0Q29kZT86IGJvb2xlYW47XG4gIC8qKiAgVGhlIG51bWJlciBvZiBsaW5lcyB0byBzaG93IGFib3ZlIHRoZSBlcnJvci4gZGVmYXVsdDogMiAqL1xuICBsaW5lc0Fib3ZlPzogbnVtYmVyO1xuICAvKiogIFRoZSBudW1iZXIgb2YgbGluZXMgdG8gc2hvdyBiZWxvdyB0aGUgZXJyb3IuIGRlZmF1bHQ6IDMgKi9cbiAgbGluZXNCZWxvdz86IG51bWJlcjtcbiAgLyoqXG4gICAqIEZvcmNpYmx5IHN5bnRheCBoaWdobGlnaHQgdGhlIGNvZGUgYXMgSmF2YVNjcmlwdCAoZm9yIG5vbi10ZXJtaW5hbHMpO1xuICAgKiBvdmVycmlkZXMgaGlnaGxpZ2h0Q29kZS5cbiAgICogZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIGZvcmNlQ29sb3I/OiBib29sZWFuO1xuICAvKipcbiAgICogUGFzcyBpbiBhIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW5saW5lIChpZiBwb3NzaWJsZSkgbmV4dCB0byB0aGVcbiAgICogaGlnaGxpZ2h0ZWQgbG9jYXRpb24gaW4gdGhlIGNvZGUuIElmIGl0IGNhbid0IGJlIHBvc2l0aW9uZWQgaW5saW5lLFxuICAgKiBpdCB3aWxsIGJlIHBsYWNlZCBhYm92ZSB0aGUgY29kZSBmcmFtZS5cbiAgICogZGVmYXVsdDogbm90aGluZ1xuICAgKi9cbiAgbWVzc2FnZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZWdFeHAgdG8gdGVzdCBmb3IgbmV3bGluZXMgaW4gdGVybWluYWwuXG4gKi9cblxuY29uc3QgTkVXTElORSA9IC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8qKlxuICogRXh0cmFjdCB3aGF0IGxpbmVzIHNob3VsZCBiZSBtYXJrZWQgYW5kIGhpZ2hsaWdodGVkLlxuICovXG5cbnR5cGUgTWFya2VyTGluZXMgPSBSZWNvcmQ8bnVtYmVyLCB0cnVlIHwgW251bWJlciwgbnVtYmVyXT47XG5cbmZ1bmN0aW9uIGdldE1hcmtlckxpbmVzKFxuICBsb2M6IE5vZGVMb2NhdGlvbixcbiAgc291cmNlOiBBcnJheTxzdHJpbmc+LFxuICBvcHRzOiBPcHRpb25zLFxuKToge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgbWFya2VyTGluZXM6IE1hcmtlckxpbmVzO1xufSB7XG4gIGNvbnN0IHN0YXJ0TG9jOiBMb2NhdGlvbiA9IHtcbiAgICBjb2x1bW46IDAsXG4gICAgbGluZTogLTEsXG4gICAgLi4ubG9jLnN0YXJ0LFxuICB9O1xuICBjb25zdCBlbmRMb2M6IExvY2F0aW9uID0ge1xuICAgIC4uLnN0YXJ0TG9jLFxuICAgIC4uLmxvYy5lbmQsXG4gIH07XG4gIGNvbnN0IHsgbGluZXNBYm92ZSA9IDIsIGxpbmVzQmVsb3cgPSAzIH0gPSBvcHRzIHx8IHt9O1xuICBjb25zdCBzdGFydExpbmUgPSBzdGFydExvYy5saW5lO1xuICBjb25zdCBzdGFydENvbHVtbiA9IHN0YXJ0TG9jLmNvbHVtbjtcbiAgY29uc3QgZW5kTGluZSA9IGVuZExvYy5saW5lO1xuICBjb25zdCBlbmRDb2x1bW4gPSBlbmRMb2MuY29sdW1uO1xuXG4gIGxldCBzdGFydCA9IE1hdGgubWF4KHN0YXJ0TGluZSAtIChsaW5lc0Fib3ZlICsgMSksIDApO1xuICBsZXQgZW5kID0gTWF0aC5taW4oc291cmNlLmxlbmd0aCwgZW5kTGluZSArIGxpbmVzQmVsb3cpO1xuXG4gIGlmIChzdGFydExpbmUgPT09IC0xKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKGVuZExpbmUgPT09IC0xKSB7XG4gICAgZW5kID0gc291cmNlLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IGxpbmVEaWZmID0gZW5kTGluZSAtIHN0YXJ0TGluZTtcbiAgY29uc3QgbWFya2VyTGluZXM6IE1hcmtlckxpbmVzID0ge307XG5cbiAgaWYgKGxpbmVEaWZmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGluZURpZmY7IGkrKykge1xuICAgICAgY29uc3QgbGluZU51bWJlciA9IGkgKyBzdGFydExpbmU7XG5cbiAgICAgIGlmICghc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgbWFya2VyTGluZXNbbGluZU51bWJlcl0gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZVtsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoO1xuXG4gICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gW3N0YXJ0Q29sdW1uLCBzb3VyY2VMZW5ndGggLSBzdGFydENvbHVtbiArIDFdO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBsaW5lRGlmZikge1xuICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IFswLCBlbmRDb2x1bW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSBpXS5sZW5ndGg7XG5cbiAgICAgICAgbWFya2VyTGluZXNbbGluZU51bWJlcl0gPSBbMCwgc291cmNlTGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXJ0Q29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgIGlmIChzdGFydENvbHVtbikge1xuICAgICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gW3N0YXJ0Q29sdW1uLCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtlckxpbmVzW3N0YXJ0TGluZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gW3N0YXJ0Q29sdW1uLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgbWFya2VyTGluZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZGVGcmFtZUNvbHVtbnMoXG4gIHJhd0xpbmVzOiBzdHJpbmcsXG4gIGxvYzogTm9kZUxvY2F0aW9uLFxuICBvcHRzOiBPcHRpb25zID0ge30sXG4pOiBzdHJpbmcge1xuICBjb25zdCBzaG91bGRIaWdobGlnaHQgPVxuICAgIG9wdHMuZm9yY2VDb2xvciB8fCAoaXNDb2xvclN1cHBvcnRlZCgpICYmIG9wdHMuaGlnaGxpZ2h0Q29kZSk7XG4gIGNvbnN0IGRlZnMgPSBnZXREZWZzKHNob3VsZEhpZ2hsaWdodCk7XG5cbiAgY29uc3QgbGluZXMgPSByYXdMaW5lcy5zcGxpdChORVdMSU5FKTtcbiAgY29uc3QgeyBzdGFydCwgZW5kLCBtYXJrZXJMaW5lcyB9ID0gZ2V0TWFya2VyTGluZXMobG9jLCBsaW5lcywgb3B0cyk7XG4gIGNvbnN0IGhhc0NvbHVtbnMgPSBsb2Muc3RhcnQgJiYgdHlwZW9mIGxvYy5zdGFydC5jb2x1bW4gPT09IFwibnVtYmVyXCI7XG5cbiAgY29uc3QgbnVtYmVyTWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG5cbiAgY29uc3QgaGlnaGxpZ2h0ZWRMaW5lcyA9IHNob3VsZEhpZ2hsaWdodCA/IGhpZ2hsaWdodChyYXdMaW5lcykgOiByYXdMaW5lcztcblxuICBsZXQgZnJhbWUgPSBoaWdobGlnaHRlZExpbmVzXG4gICAgLnNwbGl0KE5FV0xJTkUsIGVuZClcbiAgICAuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICAubWFwKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXg7XG4gICAgICBjb25zdCBwYWRkZWROdW1iZXIgPSBgICR7bnVtYmVyfWAuc2xpY2UoLW51bWJlck1heFdpZHRoKTtcbiAgICAgIGNvbnN0IGd1dHRlciA9IGAgJHtwYWRkZWROdW1iZXJ9IHxgO1xuICAgICAgY29uc3QgaGFzTWFya2VyID0gbWFya2VyTGluZXNbbnVtYmVyXTtcbiAgICAgIGNvbnN0IGxhc3RNYXJrZXJMaW5lID0gIW1hcmtlckxpbmVzW251bWJlciArIDFdO1xuICAgICAgaWYgKGhhc01hcmtlcikge1xuICAgICAgICBsZXQgbWFya2VyTGluZSA9IFwiXCI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhc01hcmtlcikpIHtcbiAgICAgICAgICBjb25zdCBtYXJrZXJTcGFjaW5nID0gbGluZVxuICAgICAgICAgICAgLnNsaWNlKDAsIE1hdGgubWF4KGhhc01hcmtlclswXSAtIDEsIDApKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgICAgY29uc3QgbnVtYmVyT2ZNYXJrZXJzID0gaGFzTWFya2VyWzFdIHx8IDE7XG5cbiAgICAgICAgICBtYXJrZXJMaW5lID0gW1xuICAgICAgICAgICAgXCJcXG4gXCIsXG4gICAgICAgICAgICBkZWZzLmd1dHRlcihndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSksXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIG1hcmtlclNwYWNpbmcsXG4gICAgICAgICAgICBkZWZzLm1hcmtlcihcIl5cIikucmVwZWF0KG51bWJlck9mTWFya2VycyksXG4gICAgICAgICAgXS5qb2luKFwiXCIpO1xuXG4gICAgICAgICAgaWYgKGxhc3RNYXJrZXJMaW5lICYmIG9wdHMubWVzc2FnZSkge1xuICAgICAgICAgICAgbWFya2VyTGluZSArPSBcIiBcIiArIGRlZnMubWVzc2FnZShvcHRzLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGRlZnMubWFya2VyKFwiPlwiKSxcbiAgICAgICAgICBkZWZzLmd1dHRlcihndXR0ZXIpLFxuICAgICAgICAgIGxpbmUubGVuZ3RoID4gMCA/IGAgJHtsaW5lfWAgOiBcIlwiLFxuICAgICAgICAgIG1hcmtlckxpbmUsXG4gICAgICAgIF0uam9pbihcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgICR7ZGVmcy5ndXR0ZXIoZ3V0dGVyKX0ke2xpbmUubGVuZ3RoID4gMCA/IGAgJHtsaW5lfWAgOiBcIlwifWA7XG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbihcIlxcblwiKTtcblxuICBpZiAob3B0cy5tZXNzYWdlICYmICFoYXNDb2x1bW5zKSB7XG4gICAgZnJhbWUgPSBgJHtcIiBcIi5yZXBlYXQobnVtYmVyTWF4V2lkdGggKyAxKX0ke29wdHMubWVzc2FnZX1cXG4ke2ZyYW1lfWA7XG4gIH1cblxuICBpZiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIGRlZnMucmVzZXQoZnJhbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvZGUgZnJhbWUsIGFkZGluZyBsaW5lIG51bWJlcnMsIGNvZGUgaGlnaGxpZ2h0aW5nLCBhbmQgcG9pbnRpbmcgdG8gYSBnaXZlbiBwb3NpdGlvbi5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoXG4gIHJhd0xpbmVzOiBzdHJpbmcsXG4gIGxpbmVOdW1iZXI6IG51bWJlcixcbiAgY29sTnVtYmVyPzogbnVtYmVyIHwgbnVsbCxcbiAgb3B0czogT3B0aW9ucyA9IHt9LFxuKTogc3RyaW5nIHtcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdTaG93bikge1xuICAgIGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgXCJQYXNzaW5nIGxpbmVOdW1iZXIgYW5kIGNvbE51bWJlciBpcyBkZXByZWNhdGVkIHRvIEBiYWJlbC9jb2RlLWZyYW1lLiBQbGVhc2UgdXNlIGBjb2RlRnJhbWVDb2x1bW5zYC5cIjtcblxuICAgIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgICAvLyBBIHN0cmluZyBpcyBkaXJlY3RseSBzdXBwbGllZCB0byBlbWl0V2FybmluZywgYmVjYXVzZSB3aGVuIHN1cHBseWluZyBhblxuICAgICAgLy8gRXJyb3Igb2JqZWN0IG5vZGUgdGhyb3dzIGluIHRoZSB0ZXN0cyBiZWNhdXNlIG9mIGRpZmZlcmVudCBjb250ZXh0c1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhtZXNzYWdlLCBcIkRlcHJlY2F0aW9uV2FybmluZ1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVwcmVjYXRpb25FcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIGRlcHJlY2F0aW9uRXJyb3IubmFtZSA9IFwiRGVwcmVjYXRpb25XYXJuaW5nXCI7XG4gICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB9XG4gIH1cblxuICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuXG4gIGNvbnN0IGxvY2F0aW9uOiBOb2RlTG9jYXRpb24gPSB7XG4gICAgc3RhcnQ6IHsgY29sdW1uOiBjb2xOdW1iZXIsIGxpbmU6IGxpbmVOdW1iZXIgfSxcbiAgfTtcblxuICByZXR1cm4gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jYXRpb24sIG9wdHMpO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBR08sU0FBU0EsZ0JBQWdCQSxDQUFBLEVBQUc7RUFDakMsT0FFRSxRQUFPQyxPQUFPLGlDQUFBQyxPQUFBLENBQVBELE9BQU8sT0FBSyxRQUFRLEtBQ3hCQSxPQUFPLENBQUNFLEdBQUcsQ0FBQ0MsV0FBVyxLQUFLLEdBQUcsSUFBSUgsT0FBTyxDQUFDRSxHQUFHLENBQUNDLFdBQVcsS0FBSyxPQUFPLENBQUMsR0FDdEUsS0FBSyxHQUNMQyxVQUFVLENBQUNMLGdCQUFBO0FBRW5CO0FBbUJBLElBQU1NLE9B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