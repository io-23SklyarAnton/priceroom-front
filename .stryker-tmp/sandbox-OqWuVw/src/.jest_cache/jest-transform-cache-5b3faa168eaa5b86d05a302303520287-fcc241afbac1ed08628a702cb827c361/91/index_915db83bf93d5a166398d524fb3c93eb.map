{"version":3,"names":["isColorSupported","process","_typeof","env","FORCE_COLOR","picocolors","compose","f","g","v","buildDefs","colors","keyword","cyan","capitalized","yellow","jsxIdentifier","punctuator","number","magenta","string","green","regex","comment","gray","invalid","white","bgRed","bold","gutter","marker","red","message","reset","defsOn","createColors","defsOff","getDefs","enabled","sometimesKeywords","Set","NEWLINE$1","BRACKET","tokenize","JSX_TAG","getTokenType","token","offset","text","type","helperValidatorIdentifier","isKeyword","value","isStrictReservedWord","has","test","slice","toLowerCase","_regeneratorRuntime","mark","match","wrap","tokenize$","_context","prev","next","jsTokens","exec","matchToToken","index","stop","highlight","defs","highlighted","_iterator","_createForOfIteratorHelper","_step","_loop","_step$value","split","map","str","join","s","n","done","err","e","deprecationWarningShown","NEWLINE","getMarkerLines","loc","source","opts","startLoc","Object","assign","column","line","start","endLoc","end","_ref","_ref$linesAbove","linesAbove","_ref$linesBelow","linesBelow","startLine","startColumn","endLine","endColumn","Math","max","min","length","lineDiff","markerLines","i","lineNumber","sourceLength","codeFrameColumns","rawLines","arguments","undefined","shouldHighlight","forceColor","highlightCode","lines","_getMarkerLines","hasColumns","numberMaxWidth","String","highlightedLines","frame","paddedNumber","concat","hasMarker","lastMarkerLine","markerLine","Array","isArray","markerSpacing","replace","numberOfMarkers","repeat","colNumber","emitWarning","deprecationError","Error","name","console","warn","location"],"sources":["../src/defs.ts","../src/highlight.ts","../src/index.ts"],"sourcesContent":["import picocolors, { createColors } from \"picocolors\";\nimport type { Colors, Formatter } from \"picocolors/types\";\n\nexport function isColorSupported() {\n  return (\n    // See https://github.com/alexeyraspopov/picocolors/issues/62\n    typeof process === \"object\" &&\n      (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\")\n      ? false\n      : picocolors.isColorSupported\n  );\n}\n\nexport type InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype UITokens = \"gutter\" | \"marker\" | \"message\";\n\nexport type Defs = {\n  [_ in InternalTokenType | UITokens | \"reset\"]: Formatter;\n};\n\nconst compose: <T, U, V>(f: (gv: U) => V, g: (v: T) => U) => (v: T) => V =\n  (f, g) => v =>\n    f(g(v));\n\n/**\n * Styles for token types.\n */\nfunction buildDefs(colors: Colors): Defs {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n\n    reset: colors.reset,\n  };\n}\n\nconst defsOn = buildDefs(createColors(true));\nconst defsOff = buildDefs(createColors(false));\n\nexport function getDefs(enabled: boolean): Defs {\n  return enabled ? defsOn : defsOff;\n}\n","import type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport { getDefs, type InternalTokenType } from \"./defs.ts\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\nexport function highlight(text: string) {\n  if (text === \"\") return \"\";\n\n  const defs = getDefs(true);\n\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => defs[type as InternalTokenType](str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n","import { getDefs, isColorSupported } from \"./defs.ts\";\nimport { highlight } from \"./highlight.ts\";\n\nexport { highlight };\n\nlet deprecationWarningShown = false;\n\ntype Location = {\n  column: number;\n  line: number;\n};\n\ntype NodeLocation = {\n  end?: Location;\n  start: Location;\n};\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Extract what lines should be marked and highlighted.\n */\n\ntype MarkerLines = Record<number, true | [number, number]>;\n\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Options,\n): {\n  start: number;\n  end: number;\n  markerLines: MarkerLines;\n} {\n  const startLoc: Location = {\n    column: 0,\n    line: -1,\n    ...loc.start,\n  };\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: MarkerLines = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\nexport function codeFrameColumns(\n  rawLines: string,\n  loc: NodeLocation,\n  opts: Options = {},\n): string {\n  const shouldHighlight =\n    opts.forceColor || (isColorSupported() && opts.highlightCode);\n  const defs = getDefs(shouldHighlight);\n\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n\n  const numberMaxWidth = String(end).length;\n\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n\n  let frame = highlightedLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = \"\";\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line\n            .slice(0, Math.max(hasMarker[0] - 1, 0))\n            .replace(/[^\\t]/g, \" \");\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = [\n            \"\\n \",\n            defs.gutter(gutter.replace(/\\d/g, \" \")),\n            \" \",\n            markerSpacing,\n            defs.marker(\"^\").repeat(numberOfMarkers),\n          ].join(\"\");\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += \" \" + defs.message(opts.message);\n          }\n        }\n        return [\n          defs.marker(\">\"),\n          defs.gutter(gutter),\n          line.length > 0 ? ` ${line}` : \"\",\n          markerLine,\n        ].join(\"\");\n      } else {\n        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n      }\n    })\n    .join(\"\\n\");\n\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexport default function (\n  rawLines: string,\n  lineNumber: number,\n  colNumber?: number | null,\n  opts: Options = {},\n): string {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n\n    const message =\n      \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n    if (process.emitWarning) {\n      // A string is directly supplied to emitWarning, because when supplying an\n      // Error object node throws in the tests because of different contexts\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n\n  colNumber = Math.max(colNumber, 0);\n\n  const location: NodeLocation = {\n    start: { column: colNumber, line: lineNumber },\n  };\n\n  return codeFrameColumns(rawLines, location, opts);\n}\n"],"mappings":"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","ignoreList":[]}